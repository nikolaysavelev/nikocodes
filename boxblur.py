def boxBlur(image): # эта функция будет выводить заблюренное изображение для n*n картинки
    rows_len = len(image)
    cols_len = len(image[0])
    square = [] # здесь будут храниться матрицы 3х3 из нашей матрицы n*n, чтобы искать их заблюренный пиксель
    square_row = [] # здесь будут храниться строки из матрицы 3х3, чтобы потом засовывать их в square
    blur_row = [] # здесь будут храниться строки уже из заблюренных пикселей
    blur_img = [] # итоговая матрица с заблюренными пикселями (заблюренным изображением)
    row_point, column_point = 0, 0 # это поинтеры для строк и столбцов, которые обозначают в целом наши элементы матрицы

    while (row_point <= rows_len - 3): #описание этого алгоритма внизу
        while (column_point <= cols_len - 3):

            for i in range(rp, rp + 3):
                for j in range(cp, cp + 3):
                    square_row.append(image[i][j])

                square.append(square_row)
                square_row = []

            blur_row.append(avgsquareMatrix(square))
            square = []
            cp += 1

        blur_img.append(blur_row)
        blur_row = []
        rp += 1
        cp = 0

    return blur_img


def avgsquareMatrix(square): # создаем функцию для среднего значения матрицы 3х3, а именно для поиска заблюренного пикселя
    tot_sum = 0
    avg = 0
    for i in range(3):
        for j in range(3):
            tot_sum += square[i][j] # сумма всех элементов

    avg = tot_sum // 9 # среднее значение всех элементов - ЗАБЛЮРЕННЫЙ ПИКСЕЛЬ
    return avg


"""
[[7, 4, 0, 1], rows_len = 4, cols_len = 4, на первой итерации: rp, cp = 0, 0
[5, 6, 2, 2],
[6, 10, 7, 8],
[1, 4, 2, 0]]

Возьмем для примера эту матрицу:
1) Запускаем два цикла while, где будем сравнивать rp <= (4-3) = 1, cp <= 1 - это просто сигналка выхода из цикла
2) Дальше поступаем так: мы написали функцию, которая считает заблюренный пиксель ака среднее значение матрицы, значит нам нужно сделать вот что:
    -Проходимся по нашей матрице и нам нужно как-то сосчитать заблюренные пиксели каждой из матриц 3х3, значит делаем два цикла for именно от rp, cp
    до rp + 3, cp + 3 (НАПРИМЕР, ЕСЛИ У НАС rp, cp = 0, то считаем первую матрицу 3х3, если rp или cp меняются, то следующую матрицу 3х3 и так далее)
3) Далее каждый элемент засовываем в строки, делаем строку одной из наших матриц 3х3 типо [7,4,0]. После этого, не выходя из цикла для строк,
    засовываем строку в общий массив строк square_row, который затем делаем пустым, чтоб засунуть в него по порядку 2-ую и 3-ую строку.
4) Получили массив строк одной из матриц 3х3, далее нужно засунуть его в написанную функцию, которая посчитает заблюренный пиксель для этих строк:
    на выходе получаем один элемент для будущего заблюренного выражения (крайний левый пиксель).
5) В это же время очищаем square, то есть место под нашу вторую матрицу 3х3 освобождаем и делаем cp += 1, то есть сдвигаем поинтер по столбцам на
    1 вправо, чтоб он начал считать вторую матрицу 3х3
6) После всех действий на первой строке (когда посчитал в случае 4х4 2 пикселя верхних), мы добавляем нашу строку с пикселями в общее заблюренное
    выражение и очищаем строки под новые заблюренные пиксели нижних матриц 3х3. Затем делаем rp += 1, то есть сдвигаем наш поинтер по строкам на 1
    вниз и cp делаем = 0, чтоб у нас наши циклы опять начали считать все то же самое, но для нижних матриц 3х3

"""
